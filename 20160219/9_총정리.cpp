
// 디자인 패턴의 핵심
// 1. 공통성과 가변성의 분리
//    - 변하지 않는 전체 알고리즘에서 변하는 것을 뽑아내는 것
//    A. 변하는 것을 가상함수로
//       "Template Method" : 알고리즘이나 정책을 변경
//       "Factory Mehtod"  : 어떤 클래스의 인스턴스를 생성할지를 결정

//       "실행 시간에 교체 불가능, 정책 재사용성이 떨어진다."
//       "상속 기반의 패턴 - 경직되었고, 클래스(객체가 아닌) 자체에 대한 변경

//    B. 변하는 것을 인터페이스 기반 클래스로 분리
//      - 교체 가능해야 한다. 인터페이스 기반으로 설계되어야 한다.
//        "Strategy" : 알고리즘 캡슐화
//        "State"    : 상태에 따른 동작의 변경
//        "Builder"  : 동일한 구축 공정, 다른 표현 객체를 만들 때

// 2. 간접층을 도입
//    "Adapter" : 인터페이스 불일치 간접층 도입
//    "Proxy"   : 기존 요소를 대신
//    "Bridge"  : 구현과 추상을 분리, 독립된 업데이트를 가능하게 한다.
//    "Facade"  : 하위 시스템의 복잡한 절차를 단순화하는 상위 개념의 클래스
//    "Mediator" : 복잡한 객체 간의 관계를 단순화 시켜주는 클래스

// 3. A와 B를 묶고 싶다면, 공통의 부모가 필요하다.
//    - 재귀적 포함을 사용하는 디자인 패턴 2가지
//    "Composite" : 재귀적 합성을 통한 복합 객체 구성
//    "Decorator" : 재귀적 합성을 통한 동적인 기능의 추가

// 4. 컨테이너, 복합객체의 내부 구조에 상관없이 사용하기 위한 패턴 2가지
//    "Iterator" :             "               요소를 열거
//    "Visitor"  :             "               요소에 연산을 수행

// 5. 객체의 상태를 복원하거나 명령을 처리하는 패턴
//    "Command" : 명령의 캡슐화
//    "Memento" : 객체의 상태를 저장하고 복원하는 방법을 클래스 내부에서 제공

// 6. 하나의 이벤트를 여러곳으로 전달하거나 전파하는 패턴
//    "Observer" : 객체의 변화를 여러곳으로 전파
//    "Chain of Responsibility" : 발생된 요청을 처리되지 않으면 다음 객체에게 전달

// 7. 객체의 공유 - "Flyweight"
//--------------------------------------------------------------------------
// C++ Idioms
// 1. thiscall
// 2. 공통성과 가변성의 분리
//   - 함수 포인터, 함수 객체, 템플릿(단위 전략)
// 3. 메뉴 만들기 - 메모리 관리
// 4. 이벤트를 처리하는 기술
// 5. 컨테이너를 설계하는 기술 3가지
// 6. 라이브러리 내의 main을 포함하는 기술 - Application Framework
// 7. 일반적 프로그래밍과 STL
// 8. 관찰자 패턴 - plugin
// 9. 참조 계수 기반 객체 관리
//   RefBase, sp, wp

// 디자인 패턴 23가지
// 생성 5가지 : 싱글톤, 추상팩토리, 팩토리 메소드, 빌더, 프로토타입
// 구조 7가지 : 어댑터, 프록시, 브릿지, 퍼사드, 
//              컴포지트, 데코레이터
//              플라이웨이트
// 행위 11가지 : 반복자, 방문자
//              관찰자, 책임의 전가
//				커맨드
//              템플릿 메소드, 전략, 상태
//              메멘토, 중재자, 인터프리터
